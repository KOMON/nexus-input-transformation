import { core, arg, plugin, dynamicInputMethod } from "nexus";

import { TypeConstructor, NexusTypeName } from "./types";

import {
  InputTransformer,
  ConfigExtractor,
  Transform,
} from "./input-transformer";

export interface InputTransformerPluginOptions<
  Config extends Record<string, any>,
  Input,
  Output = Input
> {
  /** The name of the input type constructor **/
  name: string;

  /** An optional documentation string **/
  description?: string;

  /**
   * the base constructor type e.g.
   * ```ts
   * // this
   * t.nonNull.string('fieldName')
   *
   * // becomes this
   * t.nonNull.inputName({ typeConstructor: 'string', ...});
   * ```
   */
  typeConstructor: TypeConstructor;

  /** A function for extracting the extension values from the argument's field config **/
  extractConfig: ConfigExtractor<Config>;

  /** A transform to apply to the values of the input field before being passed to the resolver**/
  transform: Transform<Config, Input, Output>;

  /**
   * The module path to import the types that will need to be made available for nexus' type generation
   * ```ts
   * const plugin = buildInputTransformerPlugin({
   *   // ...
   *   fieldDefModule: __filename,
   *   fieldDefExports: ['MyConfigType', 'MyTransformedInputType'],
   * })
   * ```
   */
  fieldDefModule: string;

  /**
   * The type name exports that will need to be made available for nexus' type generation
   * ```ts
   * const plugin = buildInputTransformerPlugin({
   *   // ...
   *   fieldDefModule: __filename,
   *   fieldDefExports: ['MyConfigType', 'MyTransformedInputType'],
   * })
   * ```
   */
  fieldDefExports: string[];

  /** A string representation of the config shape, either a literal type or a name brought into scope by fieldDefTypes **/
  configTypeString?: string;
}

/**
 * Build a new plugin that will apply a given transformation to all instances of
 * a generated input type named `name`
 *
 * @typeParam Config - An extension of `Record<string, any>` that will be passed to the transform
 * @typeParam Input - The input type of the transform
 * @typeParam Output - The return type of the transform, defaults to `Input`
 */
export function buildInputTransformerPlugin<
  Config extends Record<string, any>,
  Input,
  Output = Input
>({
  name,
  description = "",
  typeConstructor,
  extractConfig,
  transform,
  fieldDefModule,
  fieldDefExports,
  configTypeString = "Readonly<Record<string, any>>",
}: InputTransformerPluginOptions<Config, Input, Output>): core.NexusPlugin {
  const inputTransformer = new InputTransformer(name, extractConfig, transform);

  return plugin({
    name: `${name} Plugin`,
    description: `A plugin generated by buildInputTransformerPlugin, enabling ${name}`,
    fieldDefTypes: [
      core.printedGenTypingImport({
        module: fieldDefModule,
        bindings: fieldDefExports,
      }),
    ],
    onInstall(builder) {
      builder.addType(
        dynamicInputMethod({
          name,
          typeDescription: description,
          typeDefinition: `<FieldName extends string>(fieldName: FieldName, config: ${configTypeString}): void`,
          factory({ typeDef, args }) {
            const [fieldName, fieldConfig] = args as [
              string,
              Readonly<Record<string, any>> & Config
            ];

            const { type = undefined, ...rest } = fieldConfig;
            const config = inputTransformer.extractConfig(rest);

            typeDef[typeConstructor](fieldName, {
              ...rest,
              type,
              extensions: {
                [name]: config,
              },
            });
          },
        })
      );
    },

    onCreateFieldResolver(config) {
      const { args: argTypes } = config.fieldConfig;

      if (!argTypes) {
        return;
      }

      const transform = inputTransformer.buildResolverMiddleware(argTypes);

      if (!transform) {
        return;
      }

      return function (root, args, ctx, info, next) {
        return next(root, transform(args), ctx, info);
      };
    },
  });
}

type ArgConstructor<TypeName extends NexusTypeName, Config> = (
  config: Config
) => core.NexusArgDef<TypeName>;

/**
 * Create an argument constructor function similar to nexus core's `intArg`,
 * `stringArg`, etc.
 *
 * ```ts
 * const myArg = buildArgConstructor<'Int', MyConfig>(
 *   'myArg',
 *   'Int',
 *   (config): MyConfig => return ({ me: config.me }),
 * );
 * ```
 *
 * @typeParam BaseTypeName - a type name suitable for passing into the nexus
 *                           core `arg` function
 *
 * @typeParam Config - the shape of your input transform's configuration
 *
 * @param extensionName - the key to emplace extensions under, should match the
 *                        defined extension name for the underlying input type
 *
 * @param baseTypeName - a type name suitable for passing into the nexus core
 *                       `arg` function
 *
 * @param extractConfig - a function to extract configuration for the argument
 *                        transform from field config arguments, should match
 *                        any configuration extraction defined for the
 *                        underlying input type
 */
export function buildArgConstructor<
  BaseTypeName extends NexusTypeName,
  Config extends Record<string, any>
>(
  extensionName: string,
  baseTypeName: BaseTypeName,
  extractConfig: ConfigExtractor<Config>
): ArgConstructor<BaseTypeName, Config> {
  return (config: Config) => {
    const extensions = extractConfig(config);

    return arg({
      type: baseTypeName,
      extensions: {
        [extensionName]: extensions,
      },
    });
  };
}
